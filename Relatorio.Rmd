---
title: "Controle On-Line de Processo por atributo c/ Intervalo de Amostragem Variável - Iniciação Científica"
author: "Nome: João Victor Lauro"
date: "Data: 04/11/2024"
output:
  html_document:
    code_folding: show
    df_print: paged
    theme: spacelab
    highlight: tango
---

<style type="text/css">
.main-container {
  max-width: 1080px;
  margin-left: auto;
  margin-right: auto;
}
</style>

```{r setup, include = F}
knitr::opts_chunk$set(echo = FALSE)
```

### **Bibliotecas Utilizadas:**

```{r libraries, echo = T, include = T, message = F, warning = F}
# Bibliotecas:
library(DEoptim)
library(microbenchmark)

# Paletas de Cores Utilizadas:
  cores <- c(
    "#FF7FC6", "#D55E00", "#E69F00", "#F0E442","#0072B2", "#A2DDFF", "#009E73", ## Paleta Wong
    "#FFFFFF", "#AAAAAA", "#000000" ## Neutras
    )
```

### **Introdução**

O objetivo deste trabalho é estudar um processo de produção, cuja abordagem de controle e manutenção do sistema envolva intervalos de amostragem variáveis, para compreender o modelo probabílistico, analisar seu comportamento assintótico, e avaliar os custos de produção, inspeção, reparo e envio dos itens produzidos ao mercado.

Seja um processo de produção que, a cada unidade de tempo, produz itens individuais e independentes. Ele inicia-se operando **Sob Controle** e, em algum instante aleatório, devido a uma causa especial, fica **Fora de Controle**. Para garantir que a produção opere **Sob Controle**, a regra de monitoramento estabelece algumas situações, assegurando seu retorno às condições iniciais do processo de produção. Os tempos entre ajustes sucessivos são indepentes entre si e são denominados **Ciclos de Regeneração**. A sequência desses ciclos constituem o processo de renovação do processo. Apresenta-se a seguir a proposta de "Controle On-Line de Processo por atributo c/ Intervalo de Amostragem Variável", com erros de classificação, que considera um tempo de espera **L** até a primeira inspeção após ajuste, maior que os demais intervalos de tempo **m** entre inspeções.

Esse modelo pode seguir as seguintes distribuições:

+ Tempo Contínuo $\rightarrow$ Distribuição Exponencial
+ Tempo Discreto $\rightarrow$ Distribuição Geométrica

Neste trabalho, utilizaremos a **distribuição geométrica**, com parâmetro $\pi \in [0, 1]$ para descrever o tempo de falha do processo.

<br>

### **Controle On-Line de Processo por atributo c/ Intervalo de Amostragem Variável** {.tabset .tabset-pills}

#### **Hipóteses** {.tabset .tabset-pills}

**1) Modelo do Processo:**
O Processo de Produção segue uma distribuição geométrica com parâmetro $\pi \in [0, 1]$:

+ Função de Massa de Probabilidade (FMP):
$P(X = k) = (1 - \pi)^{k - 1} \cdot \pi, \quad k = 1, 2, 3, \dots$
+ Função de Distribuição Acumulada (FDA):
$P(X \leq k) = 1 - (1 - \pi)^k$
+ Função Geradora de Momentos (FGM):
$M_X(t) = \frac{\pi e^t}{1 - (1 - \pi)e^t}, \quad \forall \quad t < -\ln(1 - \pi)$
+ Esperança:
$E(X) = \frac{1}{\pi}$
+ Variância:
$\text{Var}(X) = \frac{1 - \pi}{\pi^2}$
  + A distribuição geométrica, assim como a exponencial, possuem a propriedade da falta de memória, ou seja, para qualquer $m, n \in \mathbb{N}$:
  $P(X > m + n \mid X > m) = P(X > n)$


**2) Situações do Processo:**
O Processo de Produção pode se encontrar em 2 situações:

+ Sob Controle $\rightarrow$ Proporção de itens produzidos é $p_{+}$;
+ Fora de Controle $\rightarrow$ Proporção de itens produzidos é $p_{-}$;
  + $p_{+}$ > $p_{-}$, ambas constantes;
  + Após a mudança de estado, a proporção de itens conformes diminui de $p_{+}$ para $p_{-}$;
  + Após a realização de um ajuste, a proporção de itens conformes retorna ao seu valor inicial $p_{+}$.
  
**3) Monitoramento do Processo:**
Para o monitorar o processo, inspeciona-se um único item de acordo com os seguintes critérios:

+ A primeira inspeção ocorre após a produção de **L** itens (Inspeciona-se o **L-ésimo** item);
+ As inspeções seguintes ocorrem após a produção de **m** itens (Inspeciona-se o **m-ésimo** item);
  + Essa abordagem visa diminuir o custo médio, uma vez que, após um ajuste, o processo certamente se inicia **Sob Controle** e seria mais ecônomico e razoável esperar mais tempo para realizar a primeira inspeção;
+ O item é submetido á uma única classificação, entre **Conforme** ou **Não-Conforme**, cujo tempo de execução é considerado desprezível e os itens inspecionados são descartados;
  + No primeiro caso, o processo de produção é classificado como **Sob Controle**, não ocorre intervenção, e continua operando normalmente;
  + No segundo caso, o processo de produção é classificado como **Fora de Controle**, ocorre intervenção, e é instantaneamente paralisado e ajustado;
  + Quando um item é declarado como **Conforme**, há uma incerteza se o processo estaria **Fora de Controle**;
+ Existe a probabilidade de ocorrer erros de classificação:
  + $\alpha$ $\rightarrow$ Item **Conforme**, Classificação **Não-Conforme**;
  + $\beta$ $\rightarrow$ Item **Não-Conforme**, Classificação **Conforme**;
+ Inversamente, existe a probabilidade de não ocorrer erros de classificação:
  + $(1 - \alpha)$ $\rightarrow$ Item **Conforme**, Classificação **Conforme**;
  + $(1 - \beta)$ $\rightarrow$ Item **Não-Conforme**, Classificação **Não-Conforme**.

<br>

##### **Funções da Distribuição Geométrica**

```{r funcoes1, echo = T, include = T, warning = F}
## Função 1: Calcula a probabilidade de X = k para uma distribuição geométrica
fdp.geometrica <- function(k, p) {
  if (k < 1) { ## Verifica se k é menor que 1 (valores inválidos para a distribuição geométrica)
    stop("k deve ser um número inteiro maior ou igual a 1.") ## Retorna um erro se k for inválido
  }
  fdp <- (1 - p)^(k - 1) * p ## Fórmula da probabilidade da distribuição geométrica
  return(fdp) ## Retorna a probabilidade calculada
}

## Função 2: Calcula a função de distribuição acumulada (CDF) para X <= k
fda.geometrica <- function(k, p) {
  if (k < 1) { ## Verifica se k é menor que 1 (valores inválidos para a CDF da distribuição geométrica)
    stop("k deve ser um número inteiro maior ou igual a 1.") ## Retorna um erro se k for inválido
  }
  fda <- 1 - (1 - p)^k ## Fórmula da CDF da distribuição geométrica
  return(fda) ## Retorna o valor da CDF
}

## Função 3: Gera n valores aleatórios seguindo a distribuição geométrica
gerador.geometrica <- function(n, p) {
  if (n <= 0) { ## Verifica se n é menor ou igual a zero
    stop("n deve ser maior que zero.") ## Retorna um erro se n for inválido
  }
  valores <- numeric(n) ## Cria um vetor vazio para armazenar os valores gerados
  for (i in 1:n) { ## Inicia um loop para gerar n valores
    u <- runif(1) ## Gera um número aleatório uniforme entre 0 e 1
    valores[i] <- ceiling(log(1 - u) / log(1 - p)) ## Aplica a fórmula inversa da CDF para gerar o valor geométrico
  }
  return(valores) ## Retorna os valores gerados
}

## Função 4: Calcula a média teórica da distribuição geométrica
media.geometrica <- function(p) {
  media <- 1 / p ## Fórmula para a média teórica da distribuição geométrica
  return(media) ## Retorna a média calculada
}

## Função 5: Calcula a variância teórica da distribuição geométrica
variancia.geometrica <- function(p) {
  variancia <- (1 - p) / (p^2) ## Fórmula para a variância teórica da distribuição geométrica
  return(variancia) ## Retorna a variância calculada
}
```

<br>

##### **Funções Amostrais**

```{r funcoes2, echo = T, include = T, warning = F}
## Função 6: Função para calcular a média de um vetor numérico
calcular.media <- function(vetor) {
  soma <- sum(vetor) ## Soma todos os elementos do vetor
  n <- length(vetor) ## Obtém o número de elementos no vetor
  media <- soma / n ## Calcula a média dividindo a soma pelo número de elementos
  return(media) ## Retorna o valor da média
}

## Função 7: Função para calcular a variância de um vetor numérico
calcular.variancia <- function(vetor) {
  media <- calcula_media(vetor) ## Calcula a média utilizando a função anterior
  desvios <- vetor - media ## Calcula os desvios de cada elemento em relação à média
  quadrados <- desvios^2 ## Eleva os desvios ao quadrado
  variancia <- sum(quadrados) / (length(vetor) - 1) ## Calcula a variância dividindo a soma dos quadrados pelo número de elementos menos 1
  return(variancia) ## Retorna o valor da variância
}

## Função 8: Função para calcular a mediana de um vetor numérico
calcular.mediana <- function(vetor) {
  vetor <- sort(vetor) ## Ordena o vetor em ordem crescente
  n <- length(vetor) ## Obtém o número de elementos no vetor
  if (n %% 2 == 0) { ## Verifica se o número de elementos é par
    mediana <- (vetor[n/2] + vetor[n/2 + 1]) / 2 ## Calcula a mediana como a média dos dois valores centrais
  } else { ## Caso o número de elementos seja ímpar
    mediana <- vetor[(n + 1) / 2] ## Seleciona o elemento central como a mediana
  }
  return(mediana) ## Retorna o valor da mediana
}
```

<br>

#### **Modelo Probabilístico** {.tabset .tabset-pills}

Há 3 Variáveis Aleatórias associadas ao item inspecionado:

+ X $\rightarrow$ Indica a real condição de conformidade do item:
  + Não é observável;
  + X = 1 $\rightarrow$ Item ```Conforme```;
  + X = 0 $\rightarrow$ Item ```Não-Conforme```.
+ Y $\rightarrow$ Indica o resultado de classificação do item obtida pela inspeção:
  + Y = 1 $\rightarrow$ Classificação ```Conforme```;
  + Y = 0 $\rightarrow$ Classificação ```Não-Conforme```.
+ Z $\rightarrow$ Indica o estado do processo no instante de produção do item:
  + Não é observável;
  + Z = 1 $\rightarrow$ Processo de produção ```Sob Controle```;
  + Z = 0 $\rightarrow$ Processo de produção ```Fora de Controle```.

As probabilidades relacionados à proporção de itens conformes/não-conformes são:

+ $P\{X = 1 \mid Z = 1\} = p_{+}$;
+ $P\{X = 1 \mid Z = 0\} = p_{-}$.

As probabilidades relacionados às classificações dos items inspecionados são:

+ $P\{Y = 1 \mid X = 1\} = 1 - \alpha$ $\rightarrow$ Item ```Conforme```, Classificação ```Conforme```;
+ $P\{Y = 0 \mid X = 0\} = 1 - \beta$ $\rightarrow$ Item ```Não-Conforme```, Classificação ```Não-Conforme```;
+ $P\{Y = 0 \mid X = 1\} = \alpha$ $\rightarrow$ Item ```Conforme```, Classificação ```Não-Conforme```;
+ $P\{Y = 1 \mid X = 0\} = \beta$ $\rightarrow$ Item ```Não-Conforme```, Classificação ```Conforme```.

As probabilidades relacionadas aos estados do processo são:

+ $P \{ Z_{1} = 1, ..., Z_{L} = 1 \mid Z_{0} = 1 \} = (1 - \pi)^{L}$ $\rightarrow$ Processo ```Sob Controle``` no primeiro ciclo corrente;
+ $P \{ Z_{1} = 1, ..., Z_{m} = 1 \mid Z_{0} = 1 \} = (1 - \pi)^{m}$ $\rightarrow$ Processo ```Sob Controle``` nos demais ciclos correntes;
+ $P \{ Z_{1} = 1, ..., Z_{L} = 0 \mid Z_{0} = 1 \} = \left[ 1 - (1 - \pi)^{L} \right]$ $\rightarrow$ Processo ```Fora de Controle``` no primeiro ciclo corrente;
+ $P \{ Z_{1} = 1, ..., Z_{m} = 0 \mid Z_{0} = 1 \} = \left[ 1 - (1 - \pi)^{m} \right]$ $\rightarrow$ Processo ```Fora de Controle``` nos demais ciclos correntes.

Se o processo estiver ```Sob Controle```, as probabilidades de ```Não Ajustar```/```Ajustar``` o processo são:

$$
\begin{align*}
p_{AS} 
= P \{Y = 1 \mid Z = 1 \} 
&= \sum_{i=0}^{1} P \{ Y = 1 , X = i \mid Z = 1 \} \\
&= \sum_{i=0}^{1} P \{ X = i \mid Z = 1 \} P \{ Y = 1 \mid X = i, Z = 1 \} \\
&= \left[ \underset{(1 - p_{+})}{\underbrace{P\{X = 0 \mid Z = 1\}}} 
\underset{\beta}{\underbrace{P\{Y = 1 \mid X = 0, Z = 1\}}} \right] 
+ \left[ \underset{p_{+}}{\underbrace{P\{X = 1 \mid Z = 1\}}} 
\underset{(1 - \alpha)}{\underbrace{P\{Y = 1 \mid X = 1, Z = 1\}}} \right] \\
&= \left[ (1 - p_{+}) \beta \right] + \left[ p_{+} (1 - \alpha) \right] 
\\\\
(1 - p_{AS})
= P \{Y = 0 \mid Z = 1 \}
&= 1 - \left[ ((1 - p_{+}) \beta ) + (p_{+} (1 - \alpha)) \right] \\
&= \left[ ((1 - p_{+}) (1 - \beta) ) + (p_{+} \alpha) \right]
\end{align*}
$$

Se o processo estiver ```Fora de Controle```, as probabilidades de ```Não Ajustar```/```Ajustar``` o processo são:

$$
\begin{align*}
p_{AF} 
= P \{Y = 1 \mid Z = 0 \} 
&= \sum_{i=0}^{1} P \{ Y = 1 , X = i \mid Z = 0 \} \\
&= \sum_{i=0}^{1} P \{ X = i \mid Z = 0 \} P \{ Y = 1 \mid X = i, Z = 0 \} \\
&= \left[ \underset{(1 - p_{-})}{\underbrace{P\{X = 0 \mid Z = 0\}}} 
\underset{\beta}{\underbrace{P\{Y = 1 \mid X = 0, Z = 0\}}} \right] 
+ \left[ \underset{p_{-}}{\underbrace{P\{X = 1 \mid Z = 0\}}} 
\underset{(1 - \alpha)}{\underbrace{P\{Y = 1 \mid X = 1, Z = 0\}}} \right] \\\\
&= \left[ (1 - p_{-}) \beta \right] + \left[ p_{-} (1 - \alpha) \right] 
\\\\
(1 - p_{AF})
=P \{Y = 0 \mid Z = 0 \} 
&= 1 - \left[ ((1 - p_{-}) \beta ) + (p_{-} (1 - \alpha)) \right] \\
&= \left[ ((1 - p_{-}) (1 - \beta) ) + (p_{-} \alpha) \right]
\end{align*}
$$

Resumindo:

+ $p_{AS} = P \{ Y = 1 \mid Z = 1 \} = \left[ (1 - p_{+}) \beta \right] + \left[ p_{+} (1 - \alpha) \right]$
+ $p_{AF} = P \{ Y = 1 \mid Z = 0 \} = \left[ (1 - p_{-}) \beta \right] + \left[ p_{-} (1 - \alpha) \right]$

<br>

##### **Funções do Modelo Probabilístico**

```{r funcoes3, echo = T, include = T, warning = F}
## Função 9: Calcula p_(AS) - Probabilidade de Não Ajustar o processo Sob Controle
calcular.p.AS <- function(p1, alfa, beta) {
  
  ## p1: probabilidade de conformidade do item sob controle (p_(+))
  ## alfa: probabilidade de classificar item conforme como não conforme
  ## beta: probabilidade de classificar item não conforme como conforme

  termo.1 <- (1 - p1) * beta ## Probabilidade de itens não conformes classificados como conformes
  termo.2 <- p1 * (1 - alfa) ## Probabilidade de itens conformes classificados como conformes
  p.AS <- termo.1 + termo.2 ## Soma os termos para calcular p_(AS)
  return(p.AS) ## Retorna p_(AS)
}

## Função 10: Calcula p_(AF) - Probabilidade de Não Ajustar o processo Fora de Controle
calcular.p.AF <- function(p2, alfa, beta) {
  
  ## p2: probabilidade de conformidade do item fora de controle (p_(-))
  ## alfa: probabilidade de classificar item conforme como não conforme
  ## beta: probabilidade de classificar item não conforme como conforme

  termo.1 <- (1 - p2) * beta ## Probabilidade de itens não conformes classificados como conformes
  termo.2 <- p2 * (1 - alfa) ## Probabilidade de itens conformes classificados como conformes
  p.AF <- termo.1 + termo.2 ## Soma os termos para calcular p_(AF)
  return(p.AF) ## Retorna p_(AF)
}
```

<br>

#### **Cadeia de Markov** {.tabset .tabset-pills}

O processo de produção, o monitoramento e a regra de decisão sobre o ajuste em cada ciclo de inspeção podem ser modelados como uma cadeia de Markov em tempo discreto, em que cada passado da cadeia representa um ciclo. Os estados da cadeia descrevem as várias combinações da situação do processo ao final de um ciclo e da consequente decisão.

O espaço de estados da cadeia é finito e dado por:

\[E = \{ (w,s); \; w = 0,1,2 \; \text{e} \; s = 0,1\}\]

+ W indica as situações possíveis de mudança do estado do processo:
  + W = 0 $\rightarrow$ Processo Sob Controle até o final do ciclo corrente;
  + W = 1 $\rightarrow$ Processo Fora de Controle, mudança ocorreu durante o ciclo corrente;
  + W = 2 $\rightarrow$ Processo Fora de Controle, mudança ocorreu durante no ciclo anterior;
+ S indica a decisão sobre o ajuste:
  + S = 0 $\rightarrow$ Processo é ajustado;
  + S = 1 $\rightarrow$ Processo não é ajustado.

A cadeia de Markov fica da seguinte forma:

$$
\begin{bmatrix}
P_{(0,0)(0,0)} & P_{(0,0)(0,1)} & P_{(0,0)(1,0)} & P_{(0,0)(1,1)} & P_{(0,0)(2,0)} & P_{(0,0)(2,1)} \\
P_{(0,1)(0,0)} & P_{(0,1)(0,1)} & P_{(0,1)(1,0)} & P_{(0,1)(1,1)} & P_{(0,1)(2,0)} & P_{(0,1)(2,1)} \\
P_{(1,0)(0,0)} & P_{(1,0)(0,1)} & P_{(1,0)(1,0)} & P_{(1,0)(1,1)} & P_{(1,0)(2,0)} & P_{(1,0)(2,1)} \\
P_{(1,1)(0,0)} & P_{(1,1)(0,1)} & P_{(1,1)(1,0)} & P_{(1,1)(1,1)} & P_{(1,1)(2,0)} & P_{(1,1)(2,1)} \\
P_{(2,0)(0,0)} & P_{(2,0)(0,1)} & P_{(2,0)(1,0)} & P_{(2,0)(1,1)} & P_{(2,0)(2,0)} & P_{(2,0)(2,1)} \\
P_{(2,1)(0,0)} & P_{(2,1)(0,1)} & P_{(2,1)(1,0)} & P_{(2,1)(1,1)} & P_{(2,1)(2,0)} & P_{(2,1)(2,1)} \\
\end{bmatrix}
$$

Na primeira, terceira e quinta linhas/colunas, o ciclo anterior/anterior não é ajustado;
Na segunda, quarta e sexta linhas/colunas, o ciclo anterior/seguinte é ajustado.

Com isso, as probabilidades de transição podem ser calculadas da seguinte forma:

Quando o ciclo anterior é ajustado (1º, 3º e 5º linhas), ou seja, (w,0), p/ w =  0, 1, 2:

  + $P_{(w,0)(0,0)} = (1 - \pi)^{L}(1 - p_{AS})$
    + A probabilidade de **não ocorrer** uma mudança na fração de **L** itens conformes $(1 - \pi)^{L}$ no ciclo seguinte, com a probabilidade $(1 - P_{AS})$ de **ajustar** quando o processo está ```Sob-Controle```;
  + $P_{(w,0)(0,1)} = (1 - \pi)^{L}p_{AS}$
    + A probabilidade de **não ocorrer** uma mudança na fração de **L** itens conformes $(1 - \pi)^{L}$ no ciclo seguinte, com a probabilidade $P_{AS}$ de **não ajustar** quando o processo está ```Sob-Controle```;
  + $P_{(w,0)(1,0)} = \left[ 1 - (1 - \pi)^{L} \right] (1 - p_{AF})$
    + A probabilidade de **ocorrer** uma mudança na fração de **L** itens conformes $\left[ 1 - (1 - \pi)^{L} \right]$ no ciclo seguinte, com a probabilidade $(1 - P_{AF})$ de **ajustar** quando o processo está ```Fora de Controle```;
  + $P_{(w,0)(1,1)} = \left[ 1 - (1 - \pi)^{L} \right] p_{AF}$
    + A probabilidade de **ocorrer** uma mudança na fração de **L** itens conformes $\left[ 1 - (1 - \pi)^{L} \right]$ no ciclo seguinte, com a probabilidade $P_{AF}$ de **não ajustar** quando o processo está ```Fora de Controle```;
  + $P_{(w,0)(2,0)} = 0$
    + O ciclo seguinte começa ```Sob-Controle```;
  + $P_{(w,0)(2,1)} = 0$
    + O ciclo seguinte começa ```Sob-Controle```.
  
Quando o ciclo anterior não é ajustado e o processo está ```Sob-Controle``` (2º linha), ou seja, (0,1):

  + $P_{(0,1)(0,0)} = (1 - \pi)^{m}(1 - p_{AS})$
    + A probabilidade de **não ocorrer** uma mudança na fração de **m** itens conformes $(1 - \pi)^{m}$ no ciclo seguinte, com a probabilidade $(1 - P_{AS})$ de **ajustar** quando o processo está ```Sob-Controle```;
  + $P_{(0,1)(0,1)} = (1 - \pi)^{m}p_{AS}$
    + A probabilidade de **não ocorrer** uma mudança na fração de **m** itens conformes $(1 - \pi)^{m}$ no ciclo seguinte, com a probabilidade $P_{AS}$ de **não ajustar** quando o processo está ```Sob-Controle```;
  + $P_{(0,1)(1,0)} = \left[ 1 - (1 - \pi)^{m} \right] (1 - p_{AF})$
    + A probabilidade de **ocorrer** uma mudança na fração de **m** itens conformes $\left[ 1 - (1 - \pi)^{m} \right]$ no ciclo seguinte, com a probabilidade $(1 - P_{AF})$ de **ajustar** quando o processo está ```Fora de Controle```;
  + $P_{(0,1)(1,1)} = \left[ 1 - (1 - \pi)^{m} \right] p_{AF}$
    + A probabilidade de **ocorrer** uma mudança na fração de **m** itens conformes $\left[ 1 - (1 - \pi)^{m} \right]$ no ciclo seguinte, com a probabilidade $P_{AF}$ de **não ajustar** quando o processo está ```Fora de Controle```;
  + $P_{(0,1)(2,0)} = 0$
    + O ciclo seguinte começa ```Sob-Controle```;
  + $P_{(0,1)(2,1)} = 0$
    + O ciclo seguinte começa ```Sob-Controle```.

Quando o ciclo anterior não é ajustado (4 e 6º linhas), ou seja, (w,1), p/ w = 1, 2:

  + $P_{(w,1)(0,0)} = 0$
    + O ciclo anterior começa ```Fora de Controle```;
  + $P_{(w,1)(0,1)} = 0$
    + O ciclo anterior começa ```Fora de Controle```;
  + $P_{(w,1)(1,0)} = 0$
    + O ciclo anterior começa ```Fora de Controle```;
  + $P_{(w,1)(1,1)} = 0$
    + O ciclo anterior começa ```Fora de Controle```;
  + $P_{(w,1)(2,0)} = 1 - p_{AF}$
    + A probabilidade $(1 - P_{AF})$ de **ajustar** quando o processo está ```Fora de Controle```;
  + $P_{(w,1)(2,1)} = p_{AF}$
    + A probabilidade $P_{AF}$ de **não ajustar** quando o processo está ```Fora de Controle```.
  
Fazendo as substituições, obtemos:

$$
\begin{bmatrix}
(1-p_{AS})(1-\pi)^L & p_{AS}(1-\pi)^L & (1-p_{AF})[1 - (1-\pi)^L] & p_{AF}[1 - (1-\pi)^L] & 0 & 0 \\
(1-p_{AS})(1-\pi)^m & p_{AS}(1-\pi)^m & (1-p_{AF})[1 - (1-\pi)^m] & p_{AF}[1 - (1-\pi)^m] & 0 & 0  \\
(1-p_{AS})(1-\pi)^L & p_{AS}(1-\pi)^L & (1-p_{AF})[1 - (1-\pi)^L] & p_{AF}[1 - (1-\pi)^L] & 0 & 0 \\
0 & 0 & 0 & 0 & 1-p_{AF} & p_{AF} \\
(1-p_{AS})(1-\pi)^L & p_{AS}(1-\pi)^L & (1-p_{AF})[1 - (1-\pi)^L] & p_{AF}[1 - (1-\pi)^L] & 0 & 0 \\
0 & 0 & 0 & 0 & 1-p_{AF} & p_{AF} \\
\end{bmatrix}
$$

<br>

##### **Funções da Cadeia de Markov**

```{r funcoes4, echo = T, include = T, warning = F}
## Função 11: Calcula a probabilidade do processo continuar "Sob Controle" por L ciclos, dado que começa "Sob Controle"
calc.prob.sob.controle.L <- function(pi, L) {
  
  ## pi: probabilidade de transição de "Fora de Controle" para "Sob Controle"
  ## L: número de ciclos correntes

  prob.sob.controle.L <- (1 - pi)^L ## Calcula a probabilidade de o processo continuar "Sob Controle" por L ciclos
  return(prob.sob.controle.L) ## Retorna a probabilidade calculada
}

## Função 12: Calcula a probabilidade do processo continuar "Sob Controle" por m ciclos, dado que começa "Sob Controle"
calc.prob.sob.controle.m <- function(pi, m) {
  
  ## pi: probabilidade de transição de "Fora de Controle" para "Sob Controle"
  ## m: número de ciclos correntes

  prob.sob.controle.m <- (1 - pi)^m ## Calcula a probabilidade de o processo continuar "Sob Controle" por m ciclos
  return(prob.sob.controle.m) ## Retorna a probabilidade calculada
}

## Função 13: Calcula a probabilidade de o processo passar para "Fora de Controle" após L ciclos, dado que começa "Sob Controle"
calc.prob.fora.controle.L <- function(pi, L) {
  
  ## pi: probabilidade de transição de "Fora de Controle" para "Sob Controle"
  ## L: número de ciclos correntes

  prob.fora.controle.L <- 1 - (1 - pi)^L ## Calcula a probabilidade de o processo passar para "Fora de Controle" após L ciclos
  return(prob.fora.controle.L) ## Retorna a probabilidade calculada
}

## Função 14: Calcula a probabilidade de o processo passar para "Fora de Controle" após m ciclos, dado que começa "Sob Controle"
calc.prob.fora.controle.m <- function(pi, m) {
  
  ## pi: probabilidade de transição de "Fora de Controle" para "Sob Controle"
  ## m: número de ciclos correntes

  prob.fora.controle.m <- 1 - (1 - pi)^m ## Calcula a probabilidade de o processo passar para "Fora de Controle" após m ciclos
  return(prob.fora.controle.m) ## Retorna a probabilidade calculada
}

calc.matriz.prob.markov <- function(p.AS, p.AF, p.AS.L, p.AF.L, p.AS.m, p.AF.m) {
  
  ## Probabilidades de transição para os diferentes estados:
  P.00.00 <- (1 - p.AS) * p.AS.L
  P.00.01 <- p.AS * p.AS.L
  P.00.10 <- (1 - p.AF) * p.AF.L
  P.00.11 <- p.AF * p.AF.L
  P.00.20 <- 0
  P.00.21 <- 0

  P.01.00 <- (1 - p.AS) * p.AS.m
  P.01.01 <- p.AS * p.AS.m
  P.01.10 <- (1 - p.AF) * p.AF.m
  P.01.11 <- p.AF * p.AF.m
  P.01.20 <- 0
  P.01.21 <- 0

  P.10.00 <- 0
  P.10.01 <- 0
  P.10.10 <- 0
  P.10.11 <- 0
  P.10.20 <- 1 - p.AF
  P.10.21 <- p.AF

  P.11.00 <- 0
  P.11.01 <- 0
  P.11.10 <- 0
  P.11.11 <- 0
  P.11.20 <- 1 - p.AF
  P.11.21 <- p.AF

  P.20.00 <- (1 - p.AS) * p.AS.L
  P.20.01 <- p.AS * p.AS.L
  P.20.10 <- (1 - p.AF) * p.AF.L
  P.20.11 <- p.AF * p.AF.L
  P.20.20 <- 0
  P.20.21 <- 0

  P.21.00 <- (1 - p.AS) * p.AS.L
  P.21.01 <- p.AS * p.AS.L
  P.21.10 <- (1 - p.AF) * p.AF.L
  P.21.11 <- p.AF * p.AF.L
  P.21.20 <- 0
  P.21.21 <- 0

  ## Matriz de transição com as probabilidades:
  matriz <- matrix(c(
    P.00.00, P.00.01, P.00.10, P.00.11, P.00.20, P.00.21,
    P.01.00, P.01.01, P.01.10, P.01.11, P.01.20, P.01.21,
    P.10.00, P.10.01, P.10.10, P.10.11, P.10.20, P.10.21,
    P.11.00, P.11.01, P.11.10, P.11.11, P.11.20, P.11.21,
    P.20.00, P.20.01, P.20.10, P.20.11, P.20.20, P.20.21,
    P.21.00, P.21.01, P.21.10, P.21.11, P.21.20, P.21.21), nrow = 6, byrow = TRUE)

  ## Nomes das linhas e colunas:
  rownames(matriz) <- c("(0,0)", "(0,1)", "(1,0)", "(1,1)", "(2,0)", "(2,1)")
  colnames(matriz) <- c("(0,0)", "(0,1)", "(1,0)", "(1,1)", "(2,0)", "(2,1)")

  return(matriz)
}
```

<br>

#### **Distribuição Estacionária da Cadeia** {.tabset .tabset-pills}

A matriz de transição P é irredutível e aperiódica, podendo-se obter sua distribuição invariante, denotada pelo vetor:

$$
\pi = 
\left[ 
\pi(w,s); \; w = 0,1,2; \; s = 0,1
\right]', 
\; com
\sum_{(w,s) \in E}^{}
\pi(w,s) = 1
$$

A probabilidade $\pi(w,s)$ pode ser vista como a proporção de tempo que o sistema de produção visita o estado (w,s), após um número suficientemente grande de inspeções.

O vetor $\pi$ é a solução do sistema de equações lineares $\pi' = \pi'P$, que pode ser reescrita como:

$$
\pi'(P - I) = 0'
\; ou
(P' - I)\pi = 0
$$

em que I é a matriz identidade, 0 o vetor nulo e P' é a transposta de P.

Portanto, o vetor $\pi$ pode ser obtido a partir da resolução desse sistema linear com a restrição acima. Pela dimensão do sistema, a solução pode ser rapidamente obtida utilizando-se de técnica numérica disponível

Além disso, é necessária a determinação da proporção de ciclos de comprimento L ou m, de cada estado da cadeia de Markov, para um número suficiente grande de inspeções. Sejam $p_{L}(w,s)$ a probabilidade de o intervalo de amostragem ter comprimento L, dado que o estado seja $(w,s)$ e $p_{m}(w,s)$, se o ciclo de monitoramento tiver comprimento m, com $p_{m}(w,s) = 1 - p_{l}(w,s)$

O comprimento do intervalo de amostragem é L apenas quando se decide intervir no processo no ciclo imediatamente anterior. Essa situação corresponde às linhas da Matriz P, com s = 0. Por exemplo, $p_{L}(0,0)$ denota a probabilidade do ciclo corrente ter comprimento L, dado que seu estado é (0,0). É necessário que o último item inspecionado tenha sido declarado não-conforme, ou seja, (0,0), (1,0), (2,0) são os possíveis estados do ciclo de monitoramento imediatamente anterior. Especificamente:

$$
p_{L}(0,0)
=
\sum_{k = 0}^{2}
P{(W_{i - 1}, S_{i - 1})}
=
(k,0)
|
(W_{i}, S_{i})
= 
(0,0)
$$

Em que $(W_{i}, S_{i})$ é a variável aleatória associada ao estado da cadeia de Markov da i-ésima inspeção.

Aplicando o teorema de Bayes no segundo termo, obtém-se:

$$
\frac
{
\sum_{k = 0}^{2}
P
\left[
(W_{i}, S_{i})
=
(0,0)
|
(W_{i - 1}, S_{i - 1})
= 
(k,0)
\right]
P
\left[
(W_{i - 1}, S_{i - 1})
=
(0,0)
\right]
}
{
P
\left[
(W_{i}, S_{i})
=
(0,0)
\right]
}
$$

Onde $P{(W_{i}, S_{i}) = (0,0) | (W_{i - 1}, S_{i - 1})} = (k,0)$ é a probabilidade de transição $P_{(k,0)(0,0)}, k = 0, 1, 2$, pelas propriedades da distribuição estacionária, temos:

$$
P(W_{i - 1}, S_{i - 1}) = (k,0) 
= 
P(W_{i}, S_{i}) = (k,0)
= 
\pi(k,0)
$$

Dessa maneira, podemos achar todos os valores de $p_{L}(w,s)$:

$$
p_{L}(0,0) 
= 
\frac 
{ 
\left[ 
\pi(0,0) 
+ 
\pi(1,0) 
+ 
\pi(2,0)
\right] 
+ 
P_{(0,0)(0,0)} 
} 
{ 
\pi(0,0) 
} 
$$

$$
p_{L}(0,0) 
= 
\frac 
{ 
\left[ 
\pi(0,0) 
+ 
\pi(1,0) 
+ 
\pi(2,0)
\right] 
+ 
P_{(0,0)(0,1)} 
} 
{ 
\pi(0,1) 
} 
$$

$$
p_{L}(0,0) 
= 
\frac 
{ 
\left[ 
\pi(0,0) 
+ 
\pi(1,0) 
+ 
\pi(2,0)
\right] 
+ 
P_{(0,0)(1,0)} 
} 
{ 
\pi(1,0) 
} 
$$

$$
p_{L}(0,0) 
= 
\frac 
{ 
\left[ 
\pi(0,0) 
+ 
\pi(1,0) 
+ 
\pi(2,0)
\right] 
+ 
P_{(0,0)(1,1)} 
} 
{ 
\pi(1,1) 
} 
$$

$$
p_{L}(2,0) 
= 
0
$$

$$
p_{L}(2,1) 
= 
0
$$

##### **Função da Distribuição Estacionária (Método LU)**

```{r funcoes5, echo = T, include = T, warning = F}
## Função 12: Calcula a distribuição estacionária para uma cadeia de Markov pelo método da decomposição LU
calcular.distribuicao.estacionaria.LU <- function(P) {
  ## Verificar se a matriz é quadrada
  if (!is.matrix(P) || nrow(P) != ncol(P)) {
    stop("A matriz de transição deve ser quadrada.")
  }
  
  n <- nrow(P)
  
  ## Modificar a matriz de transição para criar o sistema linear A * pi = 0
  A <- t(P) - diag(n)
  A[n, ] <- rep(1, n)  ## Adicionar restrição de soma das probabilidades
  
  b <- rep(0, n)
  b[n] <- 1
  
  ## Função para decomposição LU
  decomposicao_LU <- function(A) {
    n <- nrow(A)
    L <- diag(1, n)
    U <- matrix(0, n, n)
    
    for (i in 1:n) {
      for (j in i:n) {
        U[i, j] <- A[i, j] - sum(L[i, 1:(i-1)] * U[1:(i-1), j])
      }
      for (j in (i+1):n) {
        if (j <= n) {  ## Verificar limites de índices
          L[j, i] <- (A[j, i] - sum(L[j, 1:(i-1)] * U[1:(i-1), i])) / U[i, i]
        }
      }
    }
    list(L = L, U = U)
  }
  
  ## Função para resolver sistema linear L * y = b e U * x = y
  resolver_LU <- function(L, U, b) {
    n <- length(b)
    
    ## Resolver L * y = b (substituição progressiva)
    y <- numeric(n)
    for (i in 1:n) {
      y[i] <- (b[i] - sum(L[i, 1:(i-1)] * y[1:(i-1)]))
    }
    
    ## Resolver U * x = y (substituição retroativa)
    x <- numeric(n)
    for (i in n:1) {
      if (i < n) {
        x[i] <- (y[i] - sum(U[i, (i+1):n] * x[(i+1):n])) / U[i, i]
      } else {
        x[i] <- y[i] / U[i, i]
      }
    }
    
    x
  }
  
  LU <- decomposicao_LU(A) ## Decomposição LU da matriz A
  pi <- resolver_LU(LU$L, LU$U, b) ## Resolver o sistema linear A * pi = b usando a decomposição LU
  pi <- pi / sum(pi) ## Normalizar pi para garantir que a soma seja 1
  
  return(pi)
}
```

##### **Função da Distribuição Estacionária (Método QR)**

```{r funcoes6, echo = T, include = T, warning = F}
## Função 13: Calcula a distribuição estacionária para uma cadeia de Markov pelo método da decomposição QR
calcular.distribuicao.estacionaria.QR <- function(P) {
  
  ## P: Matriz de transição de probabilidade (matriz quadrada de dimensões n x n)
  
  if (!is.matrix(P) || nrow(P) != ncol(P)) {
    stop("A matriz P deve ser quadrada.") ## Verifica se P é uma matriz quadrada
  }
  
  n <- nrow(P) ## Número de estados
  
  ## Configurando o sistema linear (P' - I)π = 0 com a restrição de normalização π1 + π2 + ... + πn = 1
  A <- t(P) - diag(1, n) ## Transposta de P subtraída pela identidade
  A <- rbind(A, rep(1, n)) ## Adiciona a equação de normalização
  b <- c(rep(0, n), 1) ## Vetor de constantes (0s e 1 para a normalização)
  
  pi <- qr.solve(A, b) ## Resolve o sistema utilizando decomposição QR
  names(pi) <- paste0("pi.", 1:n) ## Nomeia os estados de forma similar à sua convenção
  
  return(pi)
}
```

##### **Função para calcular $p_{L}$**

```{r funcoes7, echo = T, include = T, warning = F}
## Função 14: Calcula a probabilidade de transição P_L(w,s) para cada estado (w,s)
calcular.pL <- function(P, pi) {
  
  ## P: Matriz de transição de probabilidade (matriz quadrada de dimensões n x n)
  ## pi: vetor contendo as probabilidades da distribuição estacionária (pi_1, pi_2, ..., pi_n)
  
  n <- nrow(P) ## Número de estados na matriz P
  pL <- rep(0, n) ## Inicializa o vetor de resultados com zeros
  
  ## Soma dos valores de pi para os estados (0,0), (1,0), (2,0)
  soma_pi_0 <- pi[1] + pi[3] + pi[5]  # Soma das probabilidades dos estados (w,s)
  
  ## Calculando as probabilidades de transição p_L(w,s) para cada estado (w,s)
  pL[1] <- (soma_pi_0 + P[1,1] + P[2,1] + P[3,1]) / (pi[1] * 100) ## P_L(0,0)
  pL[2] <- (soma_pi_0 + P[1,2] + P[2,2] + P[3,2]) / (pi[2] * 100) ## P_L(0,1)
  pL[3] <- (soma_pi_0 + P[1,3] + P[2,3] + P[3,3]) / (pi[3] * 100) ## P_L(1,0)
  pL[4] <- (soma_pi_0 + P[1,4] + P[2,4] + P[3,4]) / (pi[4] * 100) ## P_L(1,1)
  
  ## Os estados 2,0 e 2,1 possuem probabilidade zero
  pL[5] <- 0  ## P_L(2,0)
  pL[6] <- 0  ## P_L(2,1)
  
  return(pL)
}
```

<br>

#### **Custo dos Estados** {.tabset .tabset-pills}

A estrutura de custo considerada é similar áquela adotada por e em trabalhos anteriores. Consideram três componentes de custo:

+ Custo de inspeção
+ Custo de Ajuste
+ Custo de envio de item não-conforme ao mercado. Adotamos a seguinte notação:

+ $c_{ìnspeção}$ $\rightarrow$ É o custo de classificação de um item inspecionado e está presente em todos os estados da cadeia;
+ $c_{ajuste}$ $\rightarrow$ É o custo de ajustar o processo.
+ $c_{descarte(c)}$ $\rightarrow$ Custo de descartar item conforme;
+ $c_{descarte(nc)}$ $\rightarrow$ Custo de descartar item não conforme;
+ $c_{nc}$ $\rightarrow$ É o custo de itme defeituoso que segue para o consumidor final ou para as próximas etapas do processo;

Os componentes $c_{s.nc}$ $c_{s.c}$ são usados nas situações em que os itens descartados são submetidos a processos de reaproveitamento com custos diferenciados entre itens conformes e não-conformes. No caso de os itens inspecionados serem simplesmente descartados, deve-se utiilizar o custo unitário de produção, desconsiderado o sistema de controle.

A expressão geral do custo esperado de cada estado (w,s), w = 0, 1, 2 e s = 0, 1 é dada por:

+ $\phi (w,s) = c_{ìnspeção} + \varepsilon (w,s) + \theta (w,s) + \varphi (w,s)$

em que:

+ $\varepsilon (w,s)$ $\rightarrow$ É o custo esperado por ciclo referente aos itens não-conformes dentre os m - 1 ou L - 1 itens não inspecoinados que são enviados aao mercado ou às próximas etapas da produção;
+ $\theta (w,s)$ $\rightarrow$ É o custo esperado por ciclo relacionado ao item inspecionado, descartado;
+ $\varphi (w,s)$ $\rightarrow$ É o custo de ajuste do processo de produção por ciclo. Para $\forall$

<br>

##### **Custo dos estados (0,0) e (0,1)**

O item é inspecionado é classificado como conforme, mas, devido aos erros de classificação, ele pode ser realmente conforme ou não-conforme. A probabilidade do item inspecionado, declarado conforme, ser realmente conforme é:

$$
P \{ X = 1 \mid Y = 1, Z = 1 \} 
= 
\frac 
{ 
P \{ X = 1, Y = 1 \mid Z = 1 \} 
} 
{ 
P \{ Y = 1 \mid Z = 1 \} 
} 
= 
\frac 
{ 
p_{+} 
(1 - \alpha) 
} 
{ 
p_{AS} 
} 
$$

E de ser realmente não-conforme é:

$$
P \{ X = 0 \mid Y = 1, Z = 1 \} 
= 
\frac 
{ 
P \{ X = 0, Y = 1 \mid Z = 1 \} 
} 
{ 
P \{ Y = 1 \mid Z = 1 \} 
} 
= 
\frac 
{ 
(1 - p_{+}) 
\beta 
} 
{ 
p_{AS} 
} 
$$

<br>

Para o estado $(0, 0)$:

$$
\xi (0,0) 
= 
c_{nc} 
\left[ 
p_{m}(0,0) 
(m - 1) 
(1 - p_{+}) 
+ 
p_{L}(0,0) 
(L - 1) 
(1 - p_{+}) 
\right] 
$$

$$
\theta(0, 0) 
= 
c_{descarte(c)} 
\frac 
{ 
p_{+} \alpha 
} 
{1 - p_{AS} 
} 
+ 
c_{descarte(nc)} 
\frac 
{ 
(1 - p_{+}) 
(1 - \beta) 
} 
{ 
1 - p_{AS} 
} 
$$

$$
\phi(0, 0) 
= 
c_{ìnspeção} 
+ 
\xi(0, 0) 
+ 
\theta(0, 0) 
+ 
c_{ajuste} 
$$

<br>

Para o estado $(0, 1)$:

$$
\xi (0,1) 
= 
c_{nc} 
\left[ 
p_{m}(0,1) 
(m - 1) 
(1 - p_{+}) 
+ 
p_{L}(0,1) 
(L - 1) 
(1 - p_{+}) 
\right] 
$$

$$
\theta(0, 1) 
= 
c_{descarte(c)} 
\frac 
{ 
p_{+} (1 - \alpha) 
} 
{ 
p_{AS} 
} 
+ 
c_{descarte(nc)} 
\frac 
{ 
(1 - p_{+}) 
(1 - \beta) 
} 
{ 
p_{AS} 
} 
$$

$$
\phi(0, 1) 
= 
c_{ìnspeção} 
+ 
\xi(0, 1) 
+ 
\theta(0, 1) 
$$

<br>

##### **Custo dos estados (1,0) e (1,1)**

Quando a fração de conformidade se modifica durante o ciclo corrente, pelo menos um item inspecionado é produzido com o processo fora de controle. O ponto de mudança pode ocorrer em qualquer instante entre o primeiro e o último item produzido durante o ciclo. Em ciclos com intervalo entre amostragens de comprimento $m$, a probabilidade de a mudança de estado ocorrer no instante $t$ é dada por:

$$
q_{m}(t) = 
\frac 
{ 
(1 - \pi)^{t - 1} 
\pi 
} 
{ 
1 - (1 - \pi)^L 
} 
, \quad t = 1, \dots, L 
$$

Analogamente, quando o intervalo entre inspeções tem comprimento \(L\), essa probabilidade é:

$$
q_{L}(t) = 
\frac 
{ 
(1 - \pi)^{t - 1} 
\pi 
} 
{ 
1 - (1 - \pi)^m 
} 
, \quad t = 1, \dots, m 
$$

<br>

Para o estado $(1, 0)$:

$$
\xi(1, 0) 
= 
c_{nc} 
\Bigg[ 
p_{m}(1, 0) 
\sum_{t = 1}^{m} 
q_{m}(t) 
\big[ 
(t - 1) 
(1 - p_{+}) 
+ 
(m - t) 
(1 - p_{-}) 
\big] 
+ 
p_L(1, 0) 
\sum_{t=1}^{L} 
q_{L}(t) 
\big[ 
(t - 1) 
(1 - p_{+}) 
+ 
(L - t) 
(1 - p_{-}) 
\big] 
\Bigg] 
$$

$$
\theta(1, 0) 
= 
c_{descarte(c)} 
\frac 
{ 
p_{-} 
\alpha 
} 
{ 
1 - p_{AF} 
} 
+ 
c_{descarte(nc)} 
\frac 
{ 
(1 - p_{-}) 
(1 - \beta) 
} 
{ 
1 - p_{AF} 
} 
$$

$$
\phi(1, 0) 
= 
c_{ìnspeção} 
+ 
\xi(1, 0) 
+ 
\theta(1, 0) 
+ 
c_{ajuste} 
$$

<br>

Para o estado $(1, 1)$:

$$
\xi(1, 1) 
= 
c_{nc} 
\Bigg[ 
p_{m}(1, 1) 
\sum_{t = 1}^{m} 
q_{m}(t) 
\big[ 
(t - 1) 
(1 - p_{+}) 
+ 
(m - t) 
(1 - p_{-}) 
\big] 
+ 
p_L(1, 1) 
\sum_{t=1}^{L} 
q_{L}(t) 
\big[ 
(t - 1) 
(1 - p_{+}) 
+ 
(L - t) 
(1 - p_{-}) 
\big] 
\Bigg] 
$$

$$
\theta(1, 1) 
= 
c_{descarte(c)} 
\frac 
{ 
p_{-} 
(1 - \alpha) 
} 
{ 
p_{AF} 
} 
+ 
c_{descarte(nc)} 
\frac 
{ 
(1 - p_{-}) 
\beta 
} 
{ 
p_{AF} 
} 
$$

$$
\phi(1, 1) 
= 
c_{ìnspeção} 
+ 
\xi(1, 1) 
+ 
\theta(1, 1) 
$$

<br>

##### **Custo dos Estados (2, 0) e (2, 1)**

Para o estado $(2, 0)$:

$$
\xi(2, 0) 
= 
c_{nc} 
(1 - p_{-}) 
(m - 1) 
$$

$$
\theta(2, 0) 
= 
c_{descarte(c)} 
\frac 
{ 
p_{-} 
\alpha 
} 
{ 
1 - p_{AF} 
} 
+ 
c_{descarte(nc)} 
\frac 
{ (1 - p_{-}) 
(1 - \beta) 
} 
{ 
1 - p_{AF} 
} 
$$

$$
\phi(2, 0) 
= 
c_{ìnspeção} 
+ 
\xi(2, 0) 
+ 
\theta(2, 0) 
+ 
c_{ajuste} 
$$

<br>

Para o estado $(2, 1)$:

$$
\xi(2, 0) 
= 
c_{nc} 
(1 - p_{-}) 
(m - 1) 
$$

$$
\theta(2, 0) 
= 
c_{descarte(c)} 
\frac 
{ 
p_{-} 
(1 - \alpha) 
} 
{ 
p_{AF} 
} 
+ 
c_{descarte(nc)} 
\frac 
{ (1 - p_{-}) 
\beta 
} 
{ 
p_{AF} 
} 
$$

$$
\phi(2, 1) 
= 
c_{ìnspeção} 
+ 
\xi(2, 1) 
+ 
\theta(2, 1) 
$$

<br>

##### **Funções dos Custos dos Estados**

```{r funcoes9, echo = T, include = T, warning = F}
## Função 15: com loops for para calcular os custos dos estados
calcular.custos <- function(p_mais, p_menos, alfa, beta, 
                                   c_inspecao, c_ajuste, c_desc_c, 
                                   c_desc_nc, c_nc, p_AS, p_AF, p_L, 
                                   pi, L, m) {
  
  ## Função auxiliar para calcular q.m(t) ou q.L(t)
  calcular_q <- function(t, pi, comprimento) {
    numerador <- (1 - pi)^(t - 1) * pi ## Calcula o numerador para q.m(t) ou q.L(t)
    denominador <- 1 - (1 - pi)^comprimento ## Calcula o denominador para q.m(t) ou q.L(t)
    return(numerador / denominador) ## Retorna o valor de q.m(t) ou q.L(t)
  }
  
  ## Lista de estados possíveis
  estados <- c("(0,0)", "(0,1)", "(1,0)", "(1,1)", "(2,0)", "(2,1)") ## Define os estados possíveis
  
  ## Inicializando lista para armazenar resultados
  resultados <- list() ## Cria uma lista para armazenar os resultados dos cálculos
  
  ## Loop para calcular os custos de cada estado
  for (state in estados) {
    if (state == "(0,0)") { ## Caso o estado seja "(0,0)"
      p_m_00 <- p_L[1] ## Atribui a probabilidade p_L[1] para p_m_00
      p_L_00 <- p_L[1] ## Atribui a probabilidade p_L[1] para p_L_00
      xi <- c_nc * (p_m_00 * (m - 1) * (1 - p_mais) + p_L_00 * (L - 1) * (1 - p_mais))
      theta <- c_desc_c * (p_mais * alfa) / (ifelse(p_AS == 0, 1, p_AS)) + c_desc_nc * ((1 - p_mais) * (1 - beta)) / (ifelse(p_AS == 0, 1, p_AS))
      phi <- c_inspecao + xi + theta
      
    } else if (state == "(0,1)") { ## Caso o estado seja "(0,1)"
      p_m_01 <- p_L[2] ## Atribui a probabilidade p_L[2] para p_m_01
      p_L_01 <- p_L[2] ## Atribui a probabilidade p_L[2] para p_L_01
      xi <- c_nc * (p_m_01 * (m - 1) * (1 - p_mais) + p_L_01 * (L - 1) * (1 - p_mais))
      theta <- c_desc_c * (p_mais * (1 - alfa)) / (ifelse(p_AS == 0, 1, p_AS)) + c_desc_nc * ((1 - p_mais) * (1 - beta)) / (ifelse(p_AS == 0, 1, p_AS))
      phi <- c_inspecao + xi + theta 
      
    } else if (state == "(1,0)") { ## Caso o estado seja "(1,0)"
      p_m_10 <- p_L[1] ## Atribui a probabilidade p_L[1] para p_m_10
      p_L_10 <- p_L[1] ## Atribui a probabilidade p_L[1] para p_L_10
      xi <- c_nc * (p_m_10 * (m - 1) * (1 - p_mais) + p_L_10 * (L - 1) * (1 - p_mais))
      soma_q_m <- 0 ## Inicializa a soma de q_m
      for (t in 1:m) { ## Loop para somar os valores de q.m(t) para o estado (1,0)
        soma_q_m <- soma_q_m + calcular_q(t, pi, m) * ((t - 1) * (1 - p_mais) + (m - t) * (1 - p_menos))
      }
      soma_q_L <- 0 ## Inicializa a soma de q_L
      for (t in 1:L) { ## Loop para somar os valores de q.L(t) para o estado (1,0)
        soma_q_L <- soma_q_L + calcular_q(t, pi, L) * ((t - 1) * (1 - p_mais) + (L - t) * (1 - p_menos))
      }
      xi <- xi * (soma_q_m + soma_q_L) ## Atualiza o valor de xi com a soma de q.m(t) e q.L(t)
      theta <- c_desc_c * (p_menos * (1 - alfa)) / (ifelse(p_AF == 0, 1, p_AF)) + c_desc_nc * ((1 - p_menos) * (1 - beta)) / (ifelse(p_AF == 0, 1, p_AF))
      phi <- c_inspecao + xi + theta ## Calcula o custo total (phi) para o estado (1,0)
      
    } else if (state == "(1,1)") { ## Caso o estado seja "(1,1)"
      p_m_11 <- p_L[1] ## Atribui a probabilidade p_L[1] para p_m_11
      p_L_11 <- p_L[1] ## Atribui a probabilidade p_L[1] para p_L_11
      xi <- c_nc * (p_m_11 * (m - 1) * (1 - p_mais) + p_L_11 * (L - 1) * (1 - p_mais))
      soma_q_m <- 0 ## Inicializa a soma de q_m
      for (t in 1:m) { ## Loop para somar os valores de q.m(t) para o estado (1,1)
        soma_q_m <- soma_q_m + calcular_q(t, pi, m) * ((t - 1) * (1 - p_mais) + (m - t) * (1 - p_menos))
      }
      soma_q_L <- 0 ## Inicializa a soma de q_L
      for (t in 1:L) { ## Loop para somar os valores de q.L(t) para o estado (1,1)
        soma_q_L <- soma_q_L + calcular_q(t, pi, L) * ((t - 1) * (1 - p_mais) + (L - t) * (1 - p_menos))
      }
      xi <- xi * (soma_q_m + soma_q_L)
      theta <- c_desc_c * (p_menos * (1 - alfa)) / (ifelse(p_AF == 0, 1, p_AF)) + c_desc_nc * ((1 - p_menos) * (1 - beta)) / (ifelse(p_AF == 0, 1, p_AF))
      phi <- c_inspecao + xi + theta
      
    } else if (state == "(2,0)") { ## Caso o estado seja "(2,0)"
      xi <- c_nc * (1 - p_menos) * (m - 1)
      theta <- c_desc_c * (p_menos * alfa) / (ifelse(p_AF == 0, 1, p_AF)) + c_desc_nc * ((1 - p_menos) * (1 - beta)) / (ifelse(p_AF == 0, 1, p_AF))
      phi <- c_inspecao + xi + theta
      
    } else if (state == "(2,1)") { ## Caso o estado seja "(2,1)"
      xi <- c_nc * (1 - p_menos) * (m - 1)
      theta <- c_desc_c * (p_menos * (1 - alfa)) / (ifelse(p_AF == 0, 1, p_AF)) + c_desc_nc * ((1 - p_menos) * beta) / (ifelse(p_AF == 0, 1, p_AF))
      phi <- c_inspecao + xi + theta
    }
    
    resultados[[state]] <- list(xi = xi, theta = theta, phi = phi) ## Adiciona os resultados do estado atual na lista 'resultados'
  }
  
  return(resultados)
}
```

```{r funcoes8, echo = F, include = F, warning = F}
## Função 16: Calcula os custos de todos os estados
calcular.custos.2 <- function(p_mais, p_menos, alfa, beta, 
                             c_inspecao, c_ajuste, c_desc_c, 
                             c_desc_nc, c_nc, p_AS, p_AF, p_L, 
                             pi, L, m) {
  
  ## Função auxiliar para calcular q.m(t) ou q.L(t)
  calcular_q <- function(t, pi, comprimento) {
    numerador <- (1 - pi)^(t - 1) * pi
    denominador <- 1 - (1 - pi)^comprimento
    return(numerador / denominador)
  }
  
  ## Função para evitar divisões por zero
  evitar_zero <- function(x) {
    if (abs(x) < 1e-10) return(1e-10)
    return(x)
  }
  
  ## Função para calcular xi, theta, phi
  calcular_xi_theta_phi <- function(state, p_mais, p_menos, alfa, beta, 
                                    c_inspecao, c_ajuste, c_desc_c, 
                                    c_desc_nc, c_nc, p_AS, p_AF, p_L, 
                                    pi, L, m) {
    if (state == "(0,0)") {
      p_m_00 <- p_L[1]
      p_L_00 <- p_L[1]
      xi_00 <- c_nc * (p_m_00 * (m - 1) * (1 - p_mais) + p_L_00 * (L - 1) * (1 - p_mais))
      theta_00 <- c_desc_c * (p_mais * alfa) / evitar_zero(p_AS) + 
                  c_desc_nc * ((1 - p_mais) * (1 - beta)) / evitar_zero(p_AS)
      phi_00 <- c_inspecao + xi_00 + theta_00
      return(list(xi = xi_00, theta = theta_00, phi = phi_00))
    }
    
    if (state == "(0,1)") {
      p_m_01 <- p_L[2]
      p_L_01 <- p_L[2]
      xi_01 <- c_nc * (p_m_01 * (m - 1) * (1 - p_mais) + p_L_01 * (L - 1) * (1 - p_mais))
      theta_01 <- c_desc_c * (p_mais * (1 - alfa)) / evitar_zero(p_AS) + 
                  c_desc_nc * ((1 - p_mais) * (1 - beta)) / evitar_zero(p_AS)
      phi_01 <- c_inspecao + xi_01 + theta_01
      return(list(xi = xi_01, theta = theta_01, phi = phi_01))
    }
    
    if (state == "(1,0)") {
      p_m_10 <- p_L[1]
      p_L_10 <- p_L[1]
      xi_10 <- c_nc * (p_m_10 * (m - 1) * (1 - p_mais) + p_L_10 * (L - 1) * (1 - p_mais))
      soma_q_m <- sum(sapply(1:m, function(t) calcular_q(t, pi, m) * ((t - 1) * (1 - p_mais) + (m - t) * (1 - p_menos))))
      soma_q_L <- sum(sapply(1:L, function(t) calcular_q(t, pi, L) * ((t - 1) * (1 - p_mais) + (L - t) * (1 - p_menos))))
      xi_10 <- xi_10 * (soma_q_m + soma_q_L)
      theta_10 <- c_desc_c * (p_menos * (1 - alfa)) / evitar_zero(p_AF) + 
                  c_desc_nc * ((1 - p_menos) * (1 - beta)) / evitar_zero(p_AF)
      phi_10 <- c_inspecao + xi_10 + theta_10
      return(list(xi = xi_10, theta = theta_10, phi = phi_10))
    }
    
    if (state == "(1,1)") {
      p_m_11 <- p_L[1]
      p_L_11 <- p_L[1]
      xi_11 <- c_nc * (p_m_11 * (m - 1) * (1 - p_mais) + p_L_11 * (L - 1) * (1 - p_mais))
      soma_q_m <- sum(sapply(1:m, function(t) calcular_q(t, pi, m) * ((t - 1) * (1 - p_mais) + (m - t) * (1 - p_menos))))
      soma_q_L <- sum(sapply(1:L, function(t) calcular_q(t, pi, L) * ((t - 1) * (1 - p_mais) + (L - t) * (1 - p_menos))))
      xi_11 <- xi_11 * (soma_q_m + soma_q_L)
      theta_11 <- c_desc_c * (p_menos * (1 - alfa)) / evitar_zero(p_AF) + 
                  c_desc_nc * ((1 - p_menos) * (1 - beta)) / evitar_zero(p_AF)
      phi_11 <- c_inspecao + xi_11 + theta_11
      return(list(xi = xi_11, theta = theta_11, phi = phi_11))
    }
    
    if (state == "(2,0)") {
      xi_20 <- c_nc * (1 - p_menos) * (m - 1)
      theta_20 <- c_desc_c * (p_menos * alfa) / evitar_zero(p_AF) + 
                  c_desc_nc * ((1 - p_menos) * (1 - beta)) / evitar_zero(p_AF)
      phi_20 <- c_inspecao + xi_20 + theta_20
      return(list(xi = xi_20, theta = theta_20, phi = phi_20))
    }
    
    if (state == "(2,1)") {
      xi_21 <- c_nc * (1 - p_menos) * (m - 1)
      theta_21 <- c_desc_c * (p_menos * (1 - alfa)) / evitar_zero(p_AF) + 
                  c_desc_nc * ((1 - p_menos) * beta) / evitar_zero(p_AF)
      phi_21 <- c_inspecao + xi_21 + theta_21
      return(list(xi = xi_21, theta = theta_21, phi = phi_21))
    }
  }
  
  ## Chamando a função para todos os estados possíveis e retornando os resultados
  estados <- c("(0,0)", "(0,1)", "(1,0)", "(1,1)", "(2,0)", "(2,1)")
  resultados <- lapply(estados, calcular_xi_theta_phi, 
                       p_mais = p_mais, p_menos = p_menos, alfa = alfa, beta = beta, 
                       c_inspecao = c_inspecao, c_ajuste = c_ajuste, c_desc_c = c_desc_c, 
                       c_desc_nc = c_desc_nc, c_nc = c_nc, p_AS = p_AS, p_AF = p_AF, 
                       p_L = p_L, pi = pi, L = L, m = m)
  
  return(resultados)
}
```

<br>

#### **Aplicação Numérica e Análise de Sensibilidade** {.tabset .tabset-pills}

Geralmente, o procedimento discutido aqui pode melhorar processos de alta qualidade que empregam algum tipo de controle automático através da coleta de observações individuais.

Com isso, consideramos o seguinte exemplo:

A fabricação de circuitos integrados de alto volume apresenta dificuldades com o processo de solda, tais como "insuficiência ou excesso de solda", "projeção de solda" ou posicionamento incorreto de dispositivo ou filete". Dados históricos permitem adotar, em um processo de solda, $p_{+} = 0,999$ como a probabilidade de conformidade do processo sob controle, podendo-se usar uma distribuição geométrica com parâmetro $\pi = 0,0001$ para descrever a mudança de estado do processo, operando fora de controle, com fração de conformidade $p_{-} = 0,95$. O sistema automático de inspeção por raio X instalado na linha de produção é imperfeito, assumindo-se os erros de inspeção $\alpha = \beta = 0,01$. Os componentes de custo são estimados em $c_{inspeção} = \$ \; 0,25$, $c_{ajuste} = \$ \; 100$, $c_{nc} = \$ \; 20$, $c_{descarte(c)} = \$ \; 2$, $c_{descarte(nc)} = \$ \; 2$.

```{r parametros, echo = T, include = T, warning = F}
## Parâmetros probabilísticos do processo:
p1 <- 0.999 		## Fracao de conformes em processo sob controle
p2 <- 0.95 		  ## Fracao de conformes em processo fora de controle
pe <- 0.0001 		## Probabilidade de ocorrencia shift do processo
alfa <- 0.01 		## Probabilidade de classificar item conforme como nao conforme
beta <- 0.01 		## Probabilidade de classificar item nao conforme como conforme

## Componentes de custo:
c.inspecao <- 0.25 	## Custo de inspecao
c.ajuste <- 100 		## Custo de ajuste
c.nc <- 20 		      ## Custo de enviar items nao-conformes
c.descarte.c <- 2 	## Custo de item conforme inspecionado/descartado
c.descarte.nc <- 2 	## Custo de item nao-conforme inspecionado/descartado]

L.teste <- 100 ## Valor de L para teste
m.teste <- 25 ## Valor de m para teste
```

O objetivo é encontrar os valores de m e L:

```{r aplicacao, echo = T, include = T, warning = F}
val.p.AS <- calcular.p.AS(p1, alfa, beta) ## Calcula a probabilidade de estar sob controle (P.AS)
val.p.AF <- calcular.p.AF(p2, alfa, beta) ## Calcula a probabilidade de estar fora de controle (P.AF)

cat("P.AS:", val.p.AS, "\n", ## Imprime a probabilidade P.AS
    "P.AF:", val.p.AF, "\n") ## Imprime a probabilidade P.AF

val.p.AS.L <- calc.prob.sob.controle.L(pe, L.teste) ## Calcula a probabilidade de estar sob controle para L
val.p.AF.L <- calc.prob.fora.controle.L(pe, L.teste) ## Calcula a probabilidade de estar fora de controle para L
val.p.AS.m <- calc.prob.sob.controle.m(pe, m.teste) ## Calcula a probabilidade de estar sob controle para m
val.p.AF.m <- calc.prob.fora.controle.m(pe, m.teste) ## Calcula a probabilidade de estar fora de controle para m

cat("P.AS.L:", val.p.AS.L, "\n",  ## Imprime a probabilidade P.AS.L
    "P.AF.L:", val.p.AF.L, "\n",  ## Imprime a probabilidade P.AF.L
    "P.AS.m:", val.p.AS.m, "\n",  ## Imprime a probabilidade P.AS.m
    "P.AF.m:", val.p.AF.m, "\n")  ## Imprime a probabilidade P.AF.m

matriz.P <- calc.matriz.prob.markov(val.p.AS, val.p.AF, val.p.AS.L, val.p.AF.L, val.p.AS.m, val.p.AF.m) ## Calcula a matriz de probabilidades de transição

PI.QR <- calcular.distribuicao.estacionaria.QR(matriz.P) ## Calcula a distribuição estacionária usando o método QR
PI.LU <- calcular.distribuicao.estacionaria.LU(matriz.P) ## Calcula a distribuição estacionária usando o método LU
summary(microbenchmark(LU = calcular.distribuicao.estacionaria.LU(matriz.P), QR = calcular.distribuicao.estacionaria.QR(matriz.P), times = 100)) ## Compara o tempo de execução entre LU e QR com microbenchmark

p.L.LU <- calcular.pL(matriz.P, PI.LU) ## Calcula a probabilidade de transição usando LU
p.L.QR <- calcular.pL(matriz.P, PI.QR) ## Calcula a probabilidade de transição usando QR
p.L.LU;p.L.QR ## Compara os valores

cat("Matriz de Transição (P):\n"); matriz.P ## Imprime a matriz de transição P
cat("\nDistribuição Estacionária:\n", PI.QR) ## Imprime a distribuição estacionária calculada por QR
cat("\nProbabilidades de Transição:\n", p.L.QR) ## Imprime as probabilidades de transição

custos <- calcular.custos( ## Usa a função para calcular os custos dos estados
  p_mais = p1, p_menos = p2, alfa = alfa, beta = beta,
  c_inspecao = c.inspecao, c_ajuste = c.ajuste, 
  c_desc_c = c.descarte.c, c_desc_nc = c.descarte.nc, 
  c_nc = c.nc, p_AS = val.p.AS, p_AF = val.p.AF, p_L = p.L.QR,
  pi = pe, L = L.teste, m = m.teste
)

resultados <- data.frame( ## Cria um data.frame para armazenar os resultados dos custos de cada estado
  Estado = c("(0,0)", "(0,1)", "(1,0)", "(1,1)", "(2,0)", "(2,1)"),
  xi = round(sapply(custos, function(x) x$xi), 5),
  theta = round(sapply(custos, function(x) x$theta), 5),
  phi = round(sapply(custos, function(x) x$phi), 5)
)

resultados ## Exibe o data.frame
```

<br>

#### **Otimização Discreta** {.tabset .tabset-pills}

```{r otimizacao, echo = T, include = T, warning = F}
# Definir os valores possíveis para L e m
valores_L <- seq(100, 600, by = 2) # Ajuste os intervalos conforme necessário
valores_m <- seq(5, 100, by = 2)

# Criar um data.frame para armazenar os resultados
resultados_gerais <- data.frame(L = integer(), m = integer(), custo_unitario = numeric())

# Iterar sobre todas as combinações de L e m
for (L_teste in valores_L) {
  for (m_teste in valores_m) {
    
    # Calcular probabilidades
    val.p.AS <- calcular.p.AS(p1, alfa, beta)
    val.p.AF <- calcular.p.AF(p2, alfa, beta)
    val.p.AS.L <- calc.prob.sob.controle.L(pe, L_teste)
    val.p.AF.L <- calc.prob.fora.controle.L(pe, L_teste)
    val.p.AS.m <- calc.prob.sob.controle.m(pe, m_teste)
    val.p.AF.m <- calc.prob.fora.controle.m(pe, m_teste)
    
    matriz.P <- calc.matriz.prob.markov(val.p.AS, val.p.AF, val.p.AS.L, val.p.AF.L, val.p.AS.m, val.p.AF.m) ## Calcula a matriz de probabilidades de transição
    PI.QR <- calcular.distribuicao.estacionaria.QR(matriz.P) ## Calcular distribuição estacionária (pelo método QR)
    p.L.QR <- calcular.pL(matriz.P, PI.QR) ## Calcula probabilidades de transição
    
    custos <- calcular.custos( ## Calcular os custos de cada estado
      p_mais = p1, p_menos = p2, alfa = alfa, beta = beta,
      c_inspecao = c.inspecao, c_ajuste = c.ajuste, 
      c_desc_c = c.descarte.c, c_desc_nc = c.descarte.nc, 
      c_nc = c.nc, p_AS = val.p.AS, p_AF = val.p.AF, p_L = p.L.QR,
      pi = pe, L = L_teste, m = m_teste
    )
    
    ## Calcular custo unitário total (soma de phi dos estados)
    custo_unitario <- sum(sapply(custos, function(x) x$phi))/sum(L_teste + m_teste)
    
    # Adicionar resultado ao data.frame
    resultados_gerais <- rbind(resultados_gerais, data.frame(L = L_teste, m = m_teste, custo_unitario = custo_unitario))
  }
}

# Identificar a combinação que minimiza o custo
melhor_comb <- resultados_gerais[which.min(resultados_gerais$custo_unitario), ]
cat("Melhor combinação encontrada:\n")
print(melhor_comb)

# Visualizar os resultados gerais (opcional)
resultados_gerais
```
